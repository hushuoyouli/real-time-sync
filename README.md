原理：
在游戏开发项目中，ai 的实现现在一般都是利用到了行为树，行为树的详细介绍可以 参 考 https://www.jianshu.com/p/64b5fe01fb1c ， 总 共 分 为 条 件（Conditional ），组合（Composite），修饰（Decorator），Action（行为）。实际项目中，我们的角色的表现，都是通过 action 来控制的，比如现在在跑步，那就有一个 action 专门负责跑步的方向，动画，音乐的控制，随着时间的流逝，状态的改变，action 会在某一个时刻结束，所以一般情况下，action 都是有一个时间长度的属性，也有一部分仅仅是做一个控制就结束了，这种的时间长度我们认为是 0，不影响整体的设计，根据上面对于action 的描述，我们发现，实际角色的控制其实就是一个 action 队列，根据时间的流逝，action 一个一个执行。只要保重每一个 action 队列的里面的 action 执行的顺序和执行的开始时间，结束时间，那在客户端上面表现出来就是一致的。
帧同步实现：
表现层：
根据上面的描述，我们可以认为表现层就是一个 action 的队列，然后随着时间的流逝，按顺序把里面的 action 执行出来就好了。
表现层上面不需要保重执行的顺序一致，比如 a,b 的 action 的队列，这帧是a,b，下一帧是 b,a，没有关系，因为表现层的 action 的队列，只跟时间有关，跟其他的角色无关，仅仅是表现而已
实现难点：
时间同步：
统一采用服务器的时间，比如每隔 3 秒~5 秒，我们就会去询问服务器当前的时间值，然后得到值之后，通过一个函数，修正客户端上面的服务器的时间值。并发问题：
比如当前角色一边跑，一边在某个位置有流血，在一个aciton 里面同时表现，就不够灵活了，这个时候就会用到一种特殊的 action，这个action 其实对应于行为树里面的并发 composite(最简单的比如 Parallel),在该action 里面，包含了多个 action 队列，那产生并发的 action 处理不同的 action 队列里面，就可以完成了并发的表现了。
逻辑层：
在该层，我们利用行为树来为表现层不停的产生表现需要的action，在当前状态一致的情况下，如何保证执行逻辑后的状态在各个客户端也是一致的呢，那就是我们执行的行为树的顺序要保证一致，我们要保证每一个客户端的角色队列都是一致的，然后按照这个角色队列来执行行为树，如果不考虑误差问题，那理论上执行后的状态是一致的。
实现难点：
时间同步：
帧同步的同步包从服务器下发下来的时候，都会有一个当前逻辑帧的服务器时间值，我们在该层产生的到表现层的包，都会打上这个时间值
判断各个客户端是否同步：
我们在测试游戏的时候，需要大量的打印出日志，因为我们的action 的执行是一致的，所以日志顺序和内容也应该是一致的，所以我们大概会每隔5 帧上传一个日志的 MD5 码，服务器得到后，判断是否一致就可以了，如果不一致，说明客户端已经不一致了。先把日志放到内存中，执行完md5，写入文件，并清空内存中的日志，这样子内存中的日志也不会多，md5的计算也很快就完成了，如果出现了不一致，那会要求每一个客户端都上传整个的日志，我们可以通过日志定位问题。
防外挂问题：
我们会把每一个角色的数据计算一个 md5 码，我们会在行为树执行前判断该角色的数据的 md5，看数据是否被修改，如果修改了，就上传服务器，判该角色输，在执行行为树后计算 md5 码。
中途掉线处理：
我们在客户端可以每隔几秒就保存一下当前逻辑帧的状态，注意这里除了玩家的数据，比如血量这些外，还需要保存正在执行的树的状态，当需要恢复的时候是恢复这些数据，按照角色的顺序来保存，如果仅仅是掉线的话，那就是先恢复最新的状态，然后再追帧就可以了。如果是客户端整个闪退了，那这个时候我们就需要从服务器上面去取当场战斗的最新的快照，然后进行追帧。如果服务器没有快照，那就从下发关键帧，从0 帧开始追帧。

状态同步其实就是把逻辑层跑的放到服务器上面跑，然后把产生的表现层的action 传·给客户端而已。
基于以上的分析，实现同步的时候，服务器端需要实现的东西其实比较少，压力轻，我推荐使用 golang 来作为实现语言，分布式，可扩展性，执行效率都可以满足要求。
