原理：
在游戏开发项目中，ai 的实现现在一般都是利用到了行为树，行为树的详细介绍可以 参 考 https://www.jianshu.com/p/64b5fe01fb1c ， 总 共 分 为 条 件（Conditional ），组合（Composite），修饰（Decorator），Action（行为）。实际项目中，我们的角色的表现，都是通过 action 来控制的，比如现在在跑步，那就有一个 action 专门负责跑步的方向，动画，音乐的控制，随着时间的流逝，状态的改变，action 会在某一个时刻结束，所以一般情况下，action 都是有一个时间长度的属性，也有一部分仅仅是做一个控制就结束了，这种的时间长度我们认为是 0，不影响整体的设计，根据上面对于action 的描述，我们发现，实际角色的控制其实就是一个 action 队列，根据时间的流逝，action 一个一个执行。只要保重每一个 action 队列的里面的 action 执行的顺序和执行的开始时间，结束时间，那在客户端上面表现出来就是一致的。
帧同步实现：
表现层：
根据上面的描述，我们可以认为表现层就是一个 action 的队列，然后随着时间的流逝，按顺序把里面的 action 执行出来就好了。
表现层上面不需要保重执行的顺序一致，比如 a,b 的 action 的队列，这帧是a,b，下一帧是 b,a，没有关系，因为表现层的 action 的队列，只跟时间有关，跟其他的角色无关，仅仅是表现而已
实现难点：
时间同步：
统一采用服务器的时间，比如每隔 3 秒~5 秒，我们就会去询问服务器当前的时间值，然后得到值之后，通过一个函数，修正客户端上面的服务器的时间值。并发问题：
比如当前角色一边跑，一边在某个位置有流血，在一个aciton 里面同时表现，就不够灵活了，这个时候就会用到一种特殊的 action，这个action 其实对应于行为树里面的并发 composite(最简单的比如 Parallel),在该action 里面，包含了多个 action 队列，那产生并发的 action 处理不同的 action 队列里面，就可以完成了并发的表现了。
逻辑层：
在该层，我们利用行为树来为表现层不停的产生表现需要的action，在当前状态一致的情况下，如何保证执行逻辑后的状态在各个客户端也是一致的呢，那就是我们执行的行为树的顺序要保证一致，我们要保证每一个客户端的角色队列都是一致的，然后按照这个角色队列来执行行为树，如果不考虑误差问题，那理论上执行后的状态是一致的。
实现难点：
时间同步：
帧同步的同步包从服务器下发下来的时候，都会有一个当前逻辑帧的服务器时间值，我们在该层产生的到表现层的包，都会打上这个时间值
判断各个客户端是否同步：
我们在测试游戏的时候，需要大量的打印出日志，因为我们的action 的执行是一致的，所以日志顺序和内容也应该是一致的，所以我们大概会每隔5 帧上传一个日志的 MD5 码，服务器得到后，判断是否一致就可以了，如果不一致，说明客户端已经不一致了。先把日志放到内存中，执行完md5，写入文件，并清空内存中的日志，这样子内存中的日志也不会多，md5的计算也很快就完成了，如果出现了不一致，那会要求每一个客户端都上传整个的日志，我们可以通过日志定位问题。
防外挂问题：
我们会把每一个角色的数据计算一个 md5 码，我们会在行为树执行前判断该角色的数据的 md5，看数据是否被修改，如果修改了，就上传服务器，判该角色输，在执行行为树后计算 md5 码。
中途掉线处理：
我们在客户端可以每隔几秒就保存一下当前逻辑帧的状态，注意这里除了玩家的数据，比如血量这些外，还需要保存正在执行的树的状态，当需要恢复的时候是恢复这些数据，按照角色的顺序来保存，如果仅仅是掉线的话，那就是先恢复最新的状态，然后再追帧就可以了。如果是客户端整个闪退了，那这个时候我们就需要从服务器上面去取当场战斗的最新的快照，然后进行追帧。如果服务器没有快照，那就从下发关键帧，从0 帧开始追帧。
提前预判行为：
我们可以通过拷贝一份自己的角色的数据，然后输入自己的操作行为来预判自己的action，当我们的实际的 action 执行完了后，就可以执行这个预判出来的action。预判的行为执行时长是我们的包到服务器然后回到我们的客户端的时间，这个时间值在上面的取服务器的时间值的时候可以计算出来。（这一步最后再做）状态同步实现：
状态同步其实就是把逻辑层跑的放到服务器上面跑，然后把产生的表现层的action 传·给客户端而已。
基于以上的分析，实现同步的时候，服务器端需要实现的东西其实比较少，压力轻，我推荐使用 golang 来作为实现语言，分布式，可扩展性，执行效率都可以满足要求。
